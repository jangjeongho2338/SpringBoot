스프링 모듈 종류와 사용법

1번. Spring Modules 종류 8가지

	- Spring Framework
		- 핵심 컨테이너 및 의존성 주입 프레임워크
		- Spring MVC : model view controller로 웹 계발을 도와줌
		- Spring Web : HTTP, REST API등 웹 관련 기본 기능 제공

	- Spring WebFlux
		- Web Framework의 Reactive Stack(비동기 방식)
		- 완전한 비차단 지원(데이터를 읽고 쓰는 처리 스레드가 대가하지 않고 다른 작업을 수행하도록 전환하는 방식)

	- Spring Boot
		- 독립 실행형 Spring 애플리케이션 지원 (별도의 외부서버 설치 없이 실행가능 war, Tomcat등)
		- 서블릿 컨테이너 내장(Tomcat,Jetty,Undertow)
		- 빌트 구성을 단순화하기 위해 스타터 종속성 사용 (여러 라이브러리를 묶어서 추가 가능 1줄로 여러개의 기능 추가)
		- Spring 및 타사 라이브러리를 자동 구성함 (기본적인 user정보 적으면 알아서 자동 설정해줌)
		- XML 구성이 필요없음

	- Spring Data
		- 애플리케이션의 data저장소를 java 인터페이스로 정의 (개발자가 직접 DAO등 작성 필요 없음 인터페이스만 만들면 자동으로 댐)
		- 데이터를 저장하고 검색하는 방법을 명명 규칙을 사용 ex) findByUsername("jang") > SELECT * FROM user WHERE username = 'jang'
		- 관계형, 문서, 그래프 등을 포함한 여러 종류의 데이터베이스와 연동 기능 제공 (다양한 DB와 연동 가능)

	- Spring Security
		- 강력한 보안 프레임워크
		- 인증, 권한 부여 및 API보안을 포함한 애플리게이션 보안을 처리

	- Spring Integration
		- 메시징을 통해 내/외부 애플리케이션 간의 통합을 제공

	- Spring Batch
		- 배치 애플리케이션 개발을 가능하게 하도록 설계된 가볍고 포괄적인 배치 프레임워크
		- 로깅/추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너뛰기 및 리소스 관리	
		- 대량의 레코드를 처리하는 데 필수적인 재사용 가능한 기능을 제공

	- Spring Cloud
		- Spring을 이용한 클라우드 네이티브 애플리케이션 개발을 지원
		- 개발자가 분산 시스템에서 일반적인 패턴을 빠르게 빌드 할 수 있는 도구를 제공
		- 구성관리, 서비스 검색, 회로 차단기, 지능형 라우팅 마이크로 플록시, 제어버스등등
	
	- Spring Native
		- Spring Boot 프로젝트를 네이티브 실행 파일로 컴파일 할 수 있게 지원



2번. 스프링 부트의 특징 주요 개념 

	- 자동 설정
		- 클래스 경로에 있는 라이브러리를 기반으로 자동 구성을 제공
		- 라이브러리를 통합하는 설정이 범용적인 설정으로 자동 구성됨

	- 서버리스 개발환경
		- Tomcat, Jetty, Undertow와 같은 내장 서버가 Spring Boot에 통합되어 제공됨
		- 애플리케이션을 웹 서버에 배포할 필요가 없어 배포 절차가 간소화됨

	- 마이크로서비스
		- 소프트웨어가 잘 정의된 API를 통해 통신
		- 소규모의 독립적인 서비스로 구성됨
		- 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식
		- 독립적인 소규모 팀에서 보유
		- Spring Boot는 마이크로서비스를 개발하기에 적합함

	- 클라우드 네이티브
		- 클라우드에서 제공하는 분산 컴퓨팅 기술을 활용하는 애플리게이션을 구축 및 실행하는 개념
		- 애플리케이션은 클라우드가 제공하는 확장성, 탄력성, 복원성, 유연성을 활용하도록 설계 및 구축됨
		- 클라우드 네이티브 기술은 조직이 퍼블릭, 프라이빗, 하이브리드 클라우드에서 확장 가능한 애플리케이션을 구축하고 실행 할 수 있도록 지원
		
	- 클라우드 네이티브 애플리케이션
		- 클라우드 환경에서 동작하느 것을 전제로 개발된 애플리케이션
		- 컨테이너, 마이크로서비스, 서버리스등 특징 가짐
		- 특징
			- 독립성, 복원성, 표준기반, 비즈니스 민첩성, 자동화, 작동 중지 시간 없음

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3번. Spring Initializr의 개념과 사용법

	- Spring Initializr
		- REST API로 동작하는 웹 애플리케이션
		- Spring Project의 뼈대 구조를 자동 생성
		- 실행 중 또는 프로젝트 생성 후에 원하는 기능을 추가할 수 있음

	- Spring Initializr 사용법
		- Web Initializr을 이용 (웹사이트에서 생성
		- 명령줄을 이용 (터미널에서 명령어로 생성)
			- 명령줄에서 curl명령을 사용
			- 명령줄에서 Spring boot 명령줄 인터페이스(CLI)를 사용
		- IDE를 이용 (개발툴안에서 바로 생성)
			- Spring Tool Suite로 새 프로젝트 생성
			- IntelliJ IDEA로 새 프로젝트 생성
			- Apache NetBeans로 새 프로젝트 생성 

4번. 스프링 릴리즈 버전 종류

	- SNAPSHOT
		- 개발중 자동 빌드되는 버전
		- 개발 및 실험 중인 버전으로 미완의 신규 개발되는 기능이 있을 수 있음
	- Mn
		- Milestone build로 n은 마일스톤 번호(M1,M2,.....)
		- 배포 예정인 기능 중 일부가 미구현 상태 일 수 있음
		- SNAPSHOT보다는 안정적이지만 문제 있을 수 있음
	- RC
		- Release Candidate(배포 후보 버전)
		- 기능은 완전하고 상당히 안정적인 버전
		- GA 배포 전에 일부 변경이 있을 수 있음
	- GA or 생략
		- General Availabiblty(공개 버전)
		- 일반 사용자들이 사용할 수 있는 릴리즈(배포) 버전
		- 안정적인 버전으로 모든 기능이 완전히 구현된 버전

	- 안전성 : GA>RC>Mn>SNAPSHOT

5번. Maven에서 Scope

	- Maven은 자바 프로젝트의 빌드(build)·패키징·의존성 관리 도구
	- 항상 포함시 비효율적이므로 Scope(범위)를 설정해 언제, 어느 라이브러리(의존성)를 포함할지 지정

	- 종속성 범위
		- 종속성의 전이성을 제한하고 종속성이 클래스 경로에 포함되는 시점을 결정 (컴파일 / 실행 / 테스트)

	- 종속성 범위 종류	

	- compile (컴파일 / 실행 / 테스트 전부)
		- 기본범위, 설정하지 않으면 적용됨
		- 프로젝트의 모든 클래스 경로에서 사용할 수 있음
		- 종속 프로젝트로 전파됨
	- provided (실행 할 때는 뺌) (컴파일 / 테스트)
		- 컴파일과 유사
		- JDK 또는 컨테이너가 런타임에 종속성을 제공
		- 컴파일 및 테스트 단계에 클래스 경로에 추가되지만 런타임 단계에는 추가되지 않음
	- runtime(컴파일 할 때는 뺌) (실행 / 테스트)
		- 컴파일에는 필요하지 않지만 실행에는 필요한 종속성
		- Maven은 런타임 및 테스트 클래스 경로에 이 범위가 있는 종속성을 포함하지만 컴파일에는 포함안함
	- test (테스트만 사용) (테스트)
		- 테스트 컴파일 및 테스트 실행 단계에서만 사용 가능
	- system (컴파일 / 실행 / 테스트 전부) (단 항상 경로 지정)
		- provided와 유사하지만 명시적으로 포함된 JAR을 제공해야함
		- 항상 사용가능하며 Meven Repository에서 조회 안함
	- import (dependencyManagement 내부)
		- <dependencyManagement> 섹션의 pom 유형의 종속성에서만 지원됨
		- 종속성이 저장된 pom의 <dependencyManagement>섹션에 있는 종속성 목록으로 대체됨

6번. Maven의 빌드 단계

	- 프로젝트를 배포하기까지의 일련의 과정

	- validate : 프로젝트가 정확하고 필요한 모든 정보가 사용 가능한지 확인 (유효성 검사)
	- compile : 프로젝트의 소스코드를 컴파일 (컴파일)
	- test : 적절한 단위의 테스트 프레임워크를 사용하여 컴파일된 소스코드를 테스트 (테스트)
	- package : 컴파일된 코드를 가져와서 JAR, WAR 등의 배포 가능한 형식으로 패키징 (패키징)
	- verify : 통합 테스트 결과에 대한 모든 검사를 실행하여 품질 수준이 충족되는지 확인 (검증)
	- install : 다른 로컬 프로젝트의 종속성으로 사용하기 위해 로컬 저장소에 패키지를 설치 (설치)
	- deploy : 빌드 환경에서 수행되고 다른 개발자 및 프로젝트와 공유할 수 있도록 최종 패키지를 원격 저장소에 배포 (배포)

7번. JSP의 특징(실행단계)

	- JSP는 Jasper컴파일러에 의해 java파일로 변경됨
	- Java파일은 class파일로 컴파일됨
	- class 파일은 JVM에 의해 실행됨
	- 서버 재기동 없이 소스코드 변경 가능

8번. 스프링 부트에서 JSP 사용 안하는 이유

	- Spring boot는 클라우드 네이티브 지향
		- JSP는 실행마다 임시로 컴파일되어 class 생김
	- JSP를 사용하면 WAR로 패키징 해야됨
		- JSP 컴파일을 위해 JWA 디렉토리 구조를 준수해야함
	- 의존성 관계가 복잡해짐
		- 별도의 경로에 생성되는 JSP의 class 파일의 war내부의 의존성 관리 문제
	- 내장 서버에서 JSP의 지원이 제한적임
		- Tomcat은 JSP지원 안함
	- 유지 및 운영 관리가 어려워짐
		- JSP를 위한 별도 임시 디렉토리 관리 (실행시마다 class만들어짐 속도 느림)
	- JSP의 높은 자유도 및 성능 문제

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9번. 뷰 템플릿 엔진

	- 개발자가 템플릿을 정의할 수 있는 소프트웨어 구성요소 (HTML 뼈대를 만들어 두면 데이터만 넣으면 됨 ex) 안녕하세요. ${name}님 사용자는  name만 넣으면 됨)
	- 템플릿은 동적 콘텐츠에 대한 위치 표시자가 있는 HTML 또는 XML로 개발됨 (HTML안에 데이터가 들어갈 곳이 표시가 됨)
	- 형식과 구조가 정해진 동적 웹페이지 생성 (정해진 형식(HTML 구조)에 데이터만 넣어서 자동 완성됨 매 번 새로운 HTML코드를 안 만들어도 됨)

 10번. 동작 원리

	- HTML을 만듬 > 데이터는 서버(백엔드)가 준비함 > 템플릿 엔진이 둘을 합쳐서 페이지를 만듬

11번. 타임리프의 표현식 반복 처리 속성등 속성

	- 변수 표현식 ${...} : model에 있는 변수 이름으로 값을 불러 올 때 사용
		- th : text"${today}" today값을 controller에서 가져옴 
	- 선택 변수 표현식 *{...} : 선택된 변수의 내부 필드 값을 불러 올 때 사용
		- th : text="*{firstname}"  th : text="*{lastname}" model.addAttribute("user", new User("철수", "김")); 이렇게 2개 이상을 가져옴
	- 메시지 표현식 #{...} : 메시지 프로퍼티에 설정된 메시지 키의 값을 불러 올 때 사용
		- th : utext="#{home.welcome}"  home.welcome=환영합니다! 를 저장 후 불러옴
	- URL링크 표현식 @{...} : 템플릿의 현재 위치를 기준으로 링크 주소를 재계산하여 표현
		- th : href="@{/product/list}"  경로에 있는 것을 띄운다
	- HTML조각 표현식 ~{...} : 별도 위치에 있는 HTML Template를 불러 올 때 사용 	
		- th : insert="~{commons :: main}" 다른 HTML페이지에 메인을 만들어서 commons.html의 <div th:fragment="main">을 가져올수 있음

12번. Template Fragments

	- 웹페이지들에서 반복적으로 보여지는(header,footer)부분을 별도의 템플릿으로 제작하여 공통화 할 수 있는 기능
	- 웹 페이지에서는 별도로 제작된 Fragment를 참조하여 사용
	- 반복적인 개발을 줄일 수 있고 재사용성을 높일 수 있음
	- JSP의 <jsp:include>와 유사함
		- th : insert="~{commons :: main}" 다른 HTML페이지에 메인을 만들어서 commons.html의 <div th:fragment="main">을 가져올수 있음

13번. Spring AutoConfiguration가 무엇인지와  동작 원리

	- 애플리케이션 실행 환경이 자동 구성 조건을 만족 할 때 별도 설정 없이 Spring이 자주 사용되는 설정을 자동으로 적용해주는 기능
		- 애플리케이션에 추가된 jar 종속성에 따라 Spring 애플리케이션을 자동으로 구성
	- 자동구성의 특정 부분을 대체하기 위해 자체 구성 정의 가능
	- ex) MySQL이 클래스 경로에 있고 데이터베이스 연결 빈을 수동 구성하지 않은 경우 Spring Boot는 MySQL을 메모리 내 데이터 베이스로 자동 구성함

14번. Thymeleaf 주요 속성

	- prefix : 템플릿 파일이 어디 있는지 지정하는 경로 (기본 값: spring.mvc.view.prefix=classpath:/templates/ 만약 return "home";이라면 /templates/home.html에 지정)
	- suffix : 템플릿의 확장자명 지정 (기본 값 : spring.mvc.view.suffix=.html 만약 return "home"이라면 spring.mvc.view.suffix=home.html에 지정)
	- cache : 템플릿 캐시 사용 여부 (기본 값 : spring.thymeleaf.cache=true 기본적으론 캐시 활성화)

15번. Thymeleaf cache

	- Thymeleaf는 성능향상을 위해 한 번 읽어 들인 템플릿은 캐시하여 재사용함
	- 캐시 기능은 기본적으로 활성화 되어 있어 템플릿 변경하면 서버를 재시작해야 반영됨
	- 일반적으로 개발 시점에는 캐시를 끄고 서비스 단계에서 활성화 함
	- 다른 템플릿 엔진들도 각자의 방법으로 Cache 기능을 지원함

16번. 로깅 설정 사용할 때 로그 단계 설정 이름 심각도

	- 심각도 : 심각 X trace < debug < info < warn < error < fatal 가장 심각

실습 29 ~ 31
	클래스 이름 기준으로 로그 처리 방법 (여긴 LogibController기준) 콘솔에 메시지 출력

	- controller.java

		- private final Logger log = LoggerFactory.getLogger(LogibController.class); 콘솔에 클래스 이름 기준으로 로그를 남김 ex)LoginController - ???
		
	@Controller
	@RequestMapping

	@GETMapping("")
	public String index(){
		this.log.debug("index"); > 콘솔창에 index출력  ex)LoginController - index
		return "index"; > index.html 파일을 렌더링 함
	}

	
	@PostMapping("main") > /main 경로로 post처리 ex) 로그인할때 닉네임 제출
	public String main(@RequestParam("nickname") String nickname, Model model) { 
		> 폼에서 전송된 nickname파라미터 값을 가져옴 input name = "nickname" 값이 String nickname에 변수로 담김
		this.log.debug("main"); > 콘솔창 출력 원툴
		model.addAttribute("nickname", nickname); > nickname을  main뷰로 전달 > 템플릿에서 ${nickname}으로 출력 가능
		return "main"; > main 파일을 렌더링 함
	}

	html

	xmlns:th="http://www.thymeleaf.org" > 맨 위줄쓰며 thymeleaf의 th:text, th:if등 문법을 쓸 수 있게 해줌
	
	input type = "text" name="nickname" value="" > nickname을 입력받음

	<h1 th:text="'Hello, ' + ${nickname} + '!'"></h1> > 받은 nickname을 컨트롤러를 지나서 출력함 > Hello, nickname!

		
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

17번. HTTP 서버 푸시 방안

	- HTTP에서 단방향(서버 < 클라이언트) 메시지 수신 방안 (요청>응답 구조임)

18번. 폴링 기법

	- 폴링
		- 컴퓨터 또는 제어 장치가 외부 장치의 상태를 확인하기 위해 주기적인 요청을 통해 상태를 검사하는 방법 ( ex) 새 메시지가 있는지 확인)
		- 검사 결과 일정한 조건을 만족 할 때 적절한 처리를 수행 (현재 상태를 보내거나 새로운 데이터가 있다면 보냄 ex) 새메시지가 있습니다, 없음)
		- 연결을 유지할 필요 없음 (요청-응답이 끝나면 연결 끊어짐 지속적 연결 필요 없음)
		- 지연 및 네트워크 연결을 위한 오버헤드 발생 > 실시간 통신 아님 (주기적 확인이라 딜레이 있음)
	- 폴링 주기
		- 각 요소가 한번 모니터링 되는 시간
		- 폴링 주기는 여러 요인에 의해 달라짐 > 원하는 응답 속도(지연 임계치), 폴링의 오버헤드 등
		- 짧게 설정시 응답이 빨라지고 실시간에 가까워지지만 요청횟수가 늘어남에따라 서버 부하, 네트워크 트래픽이 생김
		- 길게 설정시 서버 부하는 줄지만 실시간성이 떨어짐

19번. ReverseAJAX와 AJAX 기법

	- AJAX
		- 브라우저에서 서비의 API를 호출 > 브라우저가 서버의 데이터 요청하고 서버가 응답함 
		- 백그라운드(비동기적)에서 프로그램적으로 서버와 통식 가능 (페이지 전체를 건드리지 않고 일부분만 변경해 새로고침할 필요가 없음)
			- Form-submit은 페이지를 새로 고침하는 방식으로 서버와 통신 (기존 방식 <form>을 submit하면 페이지 전체가 다시 로드됨)
			- 통신과정에 프로그램의 개입이 제한적임 (계속 새로고침을 해야해서 세밀하게 조작 어려움)
			- Javascript에서는 XMLhttpRequest를 사용 (JS코드가 XMLHttpRequest를 통해 서버와데이터를 주고 받음 덕분에 화면을 새로 고치치않고 가능)
		- 웹 애플리케이션의 설계 및 동작이나 흐름이나 사용성은 물론 비즈니스 모델에도 큰 영향을 미침
			- 단순 보기용 앱에서 앱처럼 빠르게 반응하는 서비스로 발전
	- Reverse AJAX
		- 서버에서 브라우저의 API를 호출 > 서버가 클라이언트 쪽 동작을 유도하거나 실행시킴
		- 동작 방식
			- 브라우저에서 브라우저가 취할 동작을 서버에 묻는 요청을 전송 (AJAX요청 보냄)
			- 서버에서는 브라우저의 API를 호출하는 Javascript 코드를 전송 (요청에 대한 응답으로 자바스크립트 코드를 보냄(해야 할 행동 들어 있음))
			- 브라우저는 서버에서 전달 받은 Javascript 코드를 실행 > 즉 서버가 명령하면 브라우저가 실행함
		- 문제점
			- 브라우저는 중간자(해커) 공격에 의해 의도치 않은 동작을 실행 할 수 있음 


20번. 챗팅 서버 메시지 처리

	1. User#n이 메시지를 서버로 전송
	2. 서버는 수신된 메시지를 접속된 다른 사용자들에게 ReverseAJAXchannel로 보냄(ReverseAJAXchannel은 서버 > 브라우저방향으로 통하는 통로 역할을함)
	3. 사용자별 Reverse AJAX Channel은 한번의 요청으로 끝나지 않기 때문에 지속적으로 Thread 대기 상태를 유지해야함

	1. /chat/push 메시지 전송을 함 > Blocking Queue에 put 큐에 데이터 넣음
	2. BlockingQueue에서 메시지가 생길 때까지 기다리고 메시지가 들어오면 그걸 꺼내서 클라이언트로 전송 
	3.  /chat/poll 요청을 통해 메시지가 도착하면 클라이언트로 보냄 > Blocking Queue에서 take 큐에서 데이터를 꺼냄

	- BlockingQueue
		- 가득 찰 경우 잠시 대기
		- 빈 경우도 잠시 대기(null값 허용 X)
		- 동시성 제어 (내부적으로 스레드간의 충돌 방지)

실습 20 ~ 22

	- private final Logger log = LoggerFactory.getLogger(LoginController.class); 클래스 기준으로 로그 남김
	- private Map<String, BlockingQueue<String>> users = new ConcurrentHashMap<>(); > 닉네임별로 메시지큐를 저장하는 자료 구조
		
	public BlockingQueue<String> addUser(string nick) { > 새 사용자 접속시 호출 nick은 접속자 이름
		BlockingQueue<string> queue = new ArrayBlockingQueue<>(100); > 메시지를 저장할 큐를 만듬
		this.users.put(nick, queue); > user에 (닉네임,큐)를 등록
		return queue; > 이 사용자의 큐를 리턴
	}
	
	public void addMessage(String nick, String msg) {
		msg - "[" + nick + "]" + msg;
		
	


------------------------------------------------------------------------------------------------------------------------------------------------------------------------

21번. WebSocket의 특징

	- 웹에서 단일 TCP(전송 제어 프로그램)연결을 통해 양방향 통신 채널을 제공하는 컴퓨터 통신 프로토콜(클라이언트와 서버간의 양방향 통신 가능)
	- 2011년 IETF에서 RFC 6455로 표준화 됨
	- 주로 브라우저와 서버 간의 양방향 통신을 위해 사용됨 ex) 실시간 채팅
		- 서버간의 통신에도 사용될 수 있음
		- 브라우저에서는 브라우저 내장 객체인 WebSocket을 사용 (별도의 라이브러리 추가 없이 사용가능)
	- 프로트콜
		- WebSocket: ws://
		- WebSocket Secure: wss://


22번. WebSocket과 HTTP 특징 차이

	- 다르지만 HTTP 포트인 443(보안 연결)과 80(일반 연결)에서 작동하도록 설계됨
	- HTTP와 호환성을 위해 Upgrade 헤더를 이용한 Handshake 과정이 필요함
		- Switching Protocol(HTTP에서 Websocket 프로토콜로 전환) > 즉 처음엔 HTTP로 연결을 시도후 이후에 프로토콜을 업데이트해서 websocket으로 바꿈
	- WebSocket은 Raw Socket와도 다름 > Raw Socket는 전선 WebSocket는 전선을 통해 주고 받는 통신임
		- Raw Socket에 얇은 응용 프로트콜이 입혀진 상태 > 둘다 TCP 연결을 쓰지만 데이터전송형식, 제어 코드등 많은 기능이 덧붙여진 응용  계층 프로토콜
	- 비 연결지향적 HTTP통신에서 양방향 통신을 위해 사용됨 > HTTP는 기본적으로 요청(Request) → 응답(Response) 구조 WebSocket은 서버에서 요청 가능
		- HTTP에 비해 오버헤드 낮음 (HTTP는 매번 요청 할 때마다 헤더를 보내야함 WebSocket은 한번만 연결 함 그 후 연결 유지 재사용)
			- 백그라운드로 네트워크 연결이 유지됨,  브라우저에서 화면처리와 별도로 관리됨
		- 짧은 대기시간 : 실시간 양방향 통신이 가능
		- 지속적인 연결 유지 : 연결을 열어 둔 상태에서 상호 메시지 교환 가능
		- 양방향으로 지속적인 통신이 가능 : 클라이언트가 먼저 요청하지 않고도 서버가 클라이언트에 콘텐츠를 보낼 수 있는 표준화된 방식, 상태 유지 가능


23번. 스프링 부트 웹소켓 서버 구현

	- WebSocketConfigurer : WebSocket 요청을 처리할 handler을 설정하는 인터페이스, Spring Boot에서 WebSocket을 활성화
	- WebSocketHandlerRegistry : WebSocketHandler와 요청 URI 매핑 정보를 설정 > 요청 URL → 어떤 핸들러가 처리할지 등록
	- WebSocketHandler : WebSocket 요청 및 생명 주기 이벤트 처리를 구현할 수 있는 인터페이스 > 즉 실제로 동작하는 부분

실습

	- public class WebSocket

------------------------------------------------------------------------------------------------------------------------------------------------------------------------

24번. HTTP 메소드의 표준 동작 멱동성

	- get : 특정 리소스의 반환(조회)을 요청, GET 요청은 오직 데이터를 받기만 함 (멱등성 지원 O)
	- HEAD : GET메소드의 요청과 동일한 응답을 요구하지만 서버의 응답이 본문을 포함하지 않음  (멱등성 지원 O)
	- POST : 새로운 하위 리소스를 생성 (멱등성 지원 X)
	- PUT : 기존 리소스를 수정하거나 리소스가 없으면 새로 생성 할 수 있음 (멱등성 지원 O)
	- DELETE : 특정 리소스를 삭제 (멱등성 지원 O)
	- CONNECT : 특정 리소스로 식별되는 서버로의 연결 터널을 맺음 (멱등성 지원 X)
	- OPTIONS : 특정 리소스의 통신 옵션을 설정하는데 사용 (멱등성 지원 O)
	- TRACE : 특정 리소스의 경로를 따라 메시지 루프백 테스트를 수행 (멱등성 지원 O)
	- PATCH : 특정 리소스의 일부분을 수정하는데 사용 (멱등성 지원 X)

실습 18 ~ 19

실습 21 ~ 25






























